#include <stdio.h>
#include "puf_prover.h"
#include "flash_handler.h"
#include "mbedtls/bignum.h"
#include "mbedtls/sha256.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/entropy.h"
#include "mbedtls/ecp.h"
#include <stddef.h>
#include "utils.h"

// Helper Function to initialise puf and ECC together
int initialize_puf_and_ECC(mbedtls_ecp_group *grp, mbedtls_ecp_point *h, mbedtls_ecp_point *C , 
                            PUF_Type *puf, puf_config_t pufConfig,
                            uint8_t *activation_code,
                            size_t activation_code_size,
                            const struct flash_area *flash_area,
                            const struct device *flash_dev,
                            bool writeToFlash){
    
    int ret = 0;
    
    ret = initialize_and_start_puf(puf,pufConfig,
        activation_code,
        activation_code_size,
        flash_area,
        flash_dev,
        writeToFlash);

    if(ret!=0){
        printf("PUF Initialisation Failed\r\n");
        return ret;
    }

    ret = init_ECC(grp,h,C);
    if(ret!=0)
    {
        printf("ECC couldn't be initiliased\r\n");
        return ret;
    }

}


int initialize_and_start_puf(PUF_Type *puf,puf_config_t pufConfig,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash){
    status_t status;
    int ret;

    /* Get default configuration and initialize the provided PUF instance */
    PUF_GetDefaultConfig(&pufConfig);
    status = PUF_Init(puf, &pufConfig);
    if (status != kStatus_Success) {
        printf("Error: PUF initialization failed!\r\n");
        return -1;
    }
    printf("PUF Initialized Successfully.\r\n");

    if (writeToFlash) {
        /* Enroll and generate the activation code */
        memset(activation_code, 0, activation_code_size);
        status = PUF_Enroll(puf, activation_code, activation_code_size);
        if (status != kStatus_Success) {
            printf("Error: PUF enrollment failed!\r\n");
            flash_area_close(flash_area);
            return -1;
        }
        printf("PUF Enroll successful. Activation Code created.\r\n");

        /* Write the activation code to flash with padding */
        ret = flash_write_padded(flash_dev, flash_area, FLASH_OFFSET_ACTIVATION_CODE,
                                 activation_code, activation_code_size);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Activation code saved in flash.\r\n");

        /* Reinitialize PUF after enrollment */
        PUF_Deinit(puf, &pufConfig);
        PUF_Init(puf, &pufConfig);
        printf("PUF Reinitialized after enrollment.\r\n");
    } else {
        /* Read the activation code from flash */
        ret = flash_read_data(flash_dev, flash_area, FLASH_OFFSET_ACTIVATION_CODE,
                              activation_code, activation_code_size);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Activation code read from flash.\r\n");
    }

    /* Start the PUF with the activation code */
    status = PUF_Start(puf, activation_code, activation_code_size);
    if (status != kStatus_Success) {
        printf("Error: PUF start failed!\r\n");
        return -1;
    }
    printf("PUF Started successfully.\r\n");

    return 0;
}


int get_puf_key(PUF_Type *puf,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash,
                          uint8_t *outputBuffer)
{
    
    uint8_t keyCode[PUF_KEY_CODE_SIZE] = {0};
    uint8_t intrinsicKey[PUF_KEY_SIZE] = {0};
    int ret;
    
    if (writeToFlash) {

        ret = PUF_SetIntrinsicKey(PUF, kPUF_KeyIndex_01, PUF_KEY_SIZE, keyCode, sizeof(keyCode));
        if (ret != 0) {
            printf("PUF Intrinsic key 1 generation failed!\r\n");
            return ret;
        }

        ret = flash_write_padded(flash_dev, flash_area, FLASH_OFFSET_INTRINSIC_KEY_1_KC,
                                 keyCode, PUF_KEY_CODE_SIZE);
        if (ret != 0) {
            printf("PUF Intrinsic key 1 KC saving to flash failed!\r\n");
            return ret;

        }
    } else {
        ret = flash_read_data(flash_dev, flash_area, FLASH_OFFSET_INTRINSIC_KEY_1_KC ,
                              keyCode, PUF_KEY_CODE_SIZE);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Intrinsic key code read from flash.\r\n");
    }

    /* Reconstruct intrinsic key from keyCode1 generated by PUF_SetIntrinsicKey() */
    ret = PUF_GetKey(PUF, keyCode, sizeof(keyCode), intrinsicKey, sizeof(intrinsicKey));
    if (ret != kStatus_Success)
    {
        printf("Error reconstructing intrinsic key!\r\n");
    }

    if (outputBuffer != NULL) {
        memcpy(outputBuffer, intrinsicKey, PUF_KEY_SIZE);
    }
    
    flash_area_close(flash_area);

    return 0;
}

void puf_deinit(PUF_Type *puf,puf_config_t pufConfig){
    PUF_Deinit(puf, &pufConfig);
}



int get_response_to_challenge(const uint8_t *c, size_t c_size, mbedtls_mpi *r, PUF_Type *puf,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash
                          ){
    
    int ret;
    uint8_t keysize = PUF_KEY_SIZE;
    uint8_t *key = malloc(keysize);
    uint8_t *hashOutput = malloc(keysize);

    ret = get_puf_key(puf,activation_code,activation_code_size,
                          flash_area,flash_dev,
                          writeToFlash,
                          key);

    if(ret!=0){
        printf("Error While Getting Response From PUF");
        return ret;
    }

    uint8_t combined[c_size + keysize];

    // Combine keyCode and challenge
    memcpy(combined, key, keysize);
    memcpy(combined + keysize, c, c_size);
   
    // Hash the combined data
    mbedtls_sha256(combined, sizeof(combined), hashOutput, 0);
    

    if (mbedtls_mpi_read_binary(r, hashOutput, PUF_KEY_SIZE) != 0) {
        free(hashOutput);
        free(key);
    	return 1;
    }

    free(hashOutput);
    free(key);

    return 0;
}


int init_ECC(mbedtls_ecp_group *grp, mbedtls_ecp_point *h, mbedtls_ecp_point *C ){
    mbedtls_ecp_group_init(grp);
	mbedtls_ecp_point_init(h);
	mbedtls_ecp_point_init(C);
	int res;
	res = mbedtls_ecp_group_load(grp, MBEDTLS_ECP_DP_SECP256R1);

    if (res != 0) {
        printf("Failed to load EC group: -0x%04X\n", -res);
        return 1;
    }
    
    mbedtls_mpi x;
	mbedtls_mpi_init(&x);
	res = mbedtls_mpi_lset(&x, CONSTANT_FOR_H_GENERATOR);  
	
     if (res != 0) {
        printf("Failed to set X");
        return 1;
    }
    
    res = mbedtls_ecp_mul(grp, h, &x, &grp->G, rand_function, NULL);
    
    if (res != 0) {
        printf("Failed to generate h point: %d\n", res);
        return 1;
    }

    return 0;
}



int perform_enrollment(mbedtls_ecp_group *grp, mbedtls_ecp_point *h, mbedtls_ecp_point *C , const uint8_t *c1, size_t c1_size, const uint8_t *c2, size_t c2_size , 
                          PUF_Type *puf,puf_config_t pufConfig,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash){
    
    
    if(initialize_puf_and_ECC(grp,h,C, puf, pufConfig, activation_code, activation_code_size, flash_area, flash_dev, writeToFlash) != 0 ){
        return 1;
    }
    
    printf("Enrollement Started\r\n");

	mbedtls_mpi mpiValue_R1, mpiValue_R2;
	mbedtls_mpi_init(&mpiValue_R1);
	mbedtls_mpi_init(&mpiValue_R2);

	if (get_response_to_challenge(c1,c1_size,&mpiValue_R1,puf,activation_code,
                          activation_code_size,
                          flash_area,
                          flash_dev,
                          writeToFlash) != 0) {
		return 1;
	}

	if (get_response_to_challenge(c2,c2_size,&mpiValue_R2,puf,activation_code,  // Write to FLash always false since it is initialised in first call
                          activation_code_size,
                          flash_area,
                          flash_dev,
                          false) != 0) {
		return 1;
	}
    
	if(mbedtls_ecp_muladd(grp, C, &mpiValue_R1, &grp->G, &mpiValue_R2, h) != 0) { // C = g * R1 + h * R2
		return 1;
	}

    puf_deinit(puf,pufConfig); // Deinitalization Of Puf

	return 0;

}



int add_mul_mod(mbedtls_mpi *mpiValue_1, mbedtls_mpi *mpiValue_2,
		mbedtls_mpi *mpiValue_R, mbedtls_mpi *mpiValue_p, mbedtls_mpi *result) {

	if (mbedtls_mpi_mul_mpi(result, mpiValue_2, mpiValue_R) != 0) {
		return 1;
	}
	if (mbedtls_mpi_add_mpi(result, result, mpiValue_1) != 0) {
		return 1;
	}
	if (mbedtls_mpi_mod_mpi(result, result, mpiValue_p) != 0) {
		return 1;
	}
	return 0;
}

// Helper Function To Convert Commitment Hex To ECC Point
int get_commitment(const char *commitment_hex, size_t commitment_size, mbedtls_ecp_group *grp, mbedtls_ecp_point *C){
    
    uint8_t commitment[commitment_size];
        
    // Convert the hex string to binary buffer
    int ret = hex_string_to_bytes(commitment_hex, commitment, sizeof(commitment));
    if (ret != 0) {
        printf("Invalid hex string or buffer size too small\n");
        return -1;
    }

    printf("Commitment received (in hex):\n");
    for (size_t i = 0; i < sizeof(commitment); i++) {
        printf("%02x ", commitment[i]);
    }
    printf("\n");

    // Deserialize commitment into C
    ret = import_commitment(grp,commitment, C);
    if (ret != 0) {
        printf("Failed to import commitment\n");
        return ret;
    }

    return 0;

}




int perform_authentication(mbedtls_ecp_group *grp, mbedtls_ecp_point *g, mbedtls_ecp_point *h, 
                        mbedtls_ecp_point *proof, mbedtls_ecp_point *C, mbedtls_mpi *result_v, 
                        mbedtls_mpi *result_w, mbedtls_mpi *nonce,const uint8_t *c1, size_t c1_size, const uint8_t *c2, size_t c2_size , 
                          PUF_Type *puf, puf_config_t pufConfig,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev, const char *commitment_hex, size_t commitment_size) {

    

    if(initialize_puf_and_ECC(grp,h,C, puf, pufConfig, activation_code, activation_code_size, flash_area, flash_dev, false) != 0 ){
        return 1;
    }


    if(get_commitment(commitment_hex, commitment_size, grp, C)!=0){
        return 1; 
    }

	unsigned char sha256_result[32];
	int res = 0;
	mbedtls_mpi mpiValue_R1, mpiValue_R2, random_r, random_u, result_c;

	mbedtls_mpi_init(&mpiValue_R1);
	mbedtls_mpi_init(&mpiValue_R2);
	mbedtls_mpi_init(&random_r);
	mbedtls_mpi_init(&random_u);
	mbedtls_mpi_init(&result_c);
    
    if (!rng_initialized) {
        if (init_random_generator() != 0) {
            printf("Random generator init failed\n");
            return 1;
        }
    }



	if (generate_random_numbers(&random_r, &random_u) != 0) {
		printf("Error in Random Process\n\n");
		return 1;
	}

	if (get_response_to_challenge(c1,c1_size,&mpiValue_R1,puf,activation_code,
                          activation_code_size,
                          flash_area,
                          flash_dev,
                          false) != 0) {
		return 1;
	}

	if (get_response_to_challenge(c2,c2_size,&mpiValue_R2,puf,activation_code,  
                          activation_code_size,
                          flash_area,
                          flash_dev,
                          false) != 0) {
		return 1;
	}

	if(mbedtls_ecp_muladd(grp, proof, &random_r, g, &random_u, h) != 0) { //proof
		return 1;
	}

    unsigned char nonce_buf[32]; // 256-bit nonce
    res = mbedtls_ctr_drbg_random(&ctr_drbg, nonce_buf, sizeof(nonce_buf));
    if (res != 0) {
        printf("Error generating nonce\n");
        return 1;
    }

    res = mbedtls_mpi_read_binary(nonce, nonce_buf, sizeof(nonce_buf));
    if (res != 0) {
        printf("Error setting nonce\n");
        return 1;
    }

	size_t olen;
	unsigned char buff[100];
	mbedtls_ecp_point_write_binary(grp, C, MBEDTLS_ECP_PF_UNCOMPRESSED, &olen, buff, sizeof(buff));
	unsigned char buff2[olen + mbedtls_mpi_size(nonce)];
	memcpy(buff2, buff, olen);
	mbedtls_mpi_write_binary(nonce, buff2 + olen, sizeof(buff2) - olen);

	sha256_hash(buff2, sizeof(buff2), sha256_result);
    mbedtls_mpi_read_string(&result_c, 16, sha256_result);

	add_mul_mod(&random_r, &result_c, &mpiValue_R1, &grp->P, result_v);
	add_mul_mod(&random_u, &result_c, &mpiValue_R2, &grp->P, result_w);

    puf_deinit(puf,pufConfig); // Deinitalization Of Puf

	return 0;

}

